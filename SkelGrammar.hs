module SkelGrammar where

-- Haskell module generated by the BNF converter

import AbsGrammar
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transId :: Id -> Result
transId x = case x of
  Id string -> failure x
transProgram :: Program -> Result
transProgram x = case x of
  PDefs defs -> failure x
transDef :: Def -> Result
transDef x = case x of
  DFun type_ id args stms -> failure x
  DFunIn type_ id args stms -> failure x
  DTypdf type_ id -> failure x
  DVarDec type_ id ids -> failure x
  DVarIn type_ id exp -> failure x
  DStruct id structdecs -> failure x
  Dusing type_ -> failure x
transStructDec :: StructDec -> Result
transStructDec x = case x of
  Struct type_ id -> failure x
transArg :: Arg -> Result
transArg x = case x of
  ArgDec1 type_ -> failure x
  ArgDec2 type_ id -> failure x
  ArgDec3 type_ id exp -> failure x
  ArgConst type_ id -> failure x
transStm :: Stm -> Result
transStm x = case x of
  StmExp exp -> failure x
  StmDec decs -> failure x
  StmReturn exp -> failure x
  StmWhile exp stm -> failure x
  StmDoWhil stm1 exp stm2 -> failure x
  StmFor type_ id exp1 exp2 exp3 stm -> failure x
  StmIf exp stm -> failure x
  StmIfElse exp stm1 stm2 -> failure x
  StmBlock stms -> failure x
  StmTypeDef type_ id -> failure x
  StmStruct id structdecs -> failure x
transDec :: Dec -> Result
transDec x = case x of
  StmDec1 type_ id -> failure x
  StmDec2 type_ id exp -> failure x
  StmDec3 type_ id ids -> failure x
transExp :: Exp -> Result
transExp x = case x of
  ExInt integer -> failure x
  ExDouble double -> failure x
  ExChar char -> failure x
  ExString strings -> failure x
  ExIndex id exp -> failure x
  ExQualConst id1 id2 -> failure x
  ExFunCall id exps -> failure x
  ExStrProj1 exp1 exp2 -> failure x
  ExStrProj2 exp1 exp2 -> failure x
  ExInc1 exp -> failure x
  ExDec1 exp -> failure x
  ExDeref exp -> failure x
  ExInc2 exp -> failure x
  ExDec2 exp -> failure x
  ExNeg exp -> failure x
  ExMult exp1 exp2 -> failure x
  ExDiv exp1 exp2 -> failure x
  ExRem exp1 exp2 -> failure x
  ExpAdd exp1 exp2 -> failure x
  ExSub exp1 exp2 -> failure x
  ExLeftSh exp1 exp2 -> failure x
  ExRightSh exp1 exp2 -> failure x
  ExComp1 exp1 exp2 -> failure x
  ExComp2 exp1 exp2 -> failure x
  ExComp3 exp1 exp2 -> failure x
  ExComp4 exp1 exp2 -> failure x
  ExEqual exp1 exp2 -> failure x
  ExInequal exp1 exp2 -> failure x
  ExConj exp1 exp2 -> failure x
  ExDisj exp1 exp2 -> failure x
  ExAssig1 exp1 exp2 -> failure x
  ExAssig2 exp1 exp2 -> failure x
  ExAssig3 exp1 exp2 -> failure x
  ExCond1 exp1 exp2 -> failure x
  ExCond2 exp1 exp2 -> failure x
  ExExep exp -> failure x
transType :: Type -> Result
transType x = case x of
  Typbool -> failure x
  Typdouble -> failure x
  Typint -> failure x
  Typvoid -> failure x

